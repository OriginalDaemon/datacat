{{define "content"}}
<!-- Time Range Picker -->
<div class="card">
    <h2>Time Range</h2>
    <p style="color: var(--text-secondary); margin-bottom: 15px;">
        Select a time range to filter metrics data. Click and drag on charts to select a sub-range.
    </p>
    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
        <div style="display: flex; flex-direction: column; gap: 5px;">
            <label style="font-size: 12px; color: var(--text-secondary);">Start Time</label>
            <input type="datetime-local" id="time-range-start" style="padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary);">
        </div>
        <div style="display: flex; flex-direction: column; gap: 5px;">
            <label style="font-size: 12px; color: var(--text-secondary);">End Time</label>
            <input type="datetime-local" id="time-range-end" style="padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary);">
        </div>
        <div style="display: flex; gap: 10px; margin-top: 18px;">
            <button onclick="applyTimeRange()" class="btn" style="padding: 8px 16px;">Apply</button>
            <button onclick="resetTimeRange()" class="btn btn-secondary" style="padding: 8px 16px;">Reset</button>
        </div>
        <div id="time-range-info" style="margin-top: 18px; font-size: 13px; color: var(--text-secondary);"></div>
    </div>
</div>

<div class="card">
    <h2>Metrics Visualization</h2>
    <p style="margin-bottom: 20px; color: #666;">
        Visualize metrics across sessions with advanced filtering. Filter by state history to analyze specific scenarios.
    </p>

    <form id="metrics-form" class="filter-form">
        <div class="form-group">
            <label for="metric_name">Metric Name *</label>
            <select id="metric_name" name="metric_name" required>
                <option value="">Select metric...</option>
                <option value="cpu_usage">CPU Usage</option>
                <option value="memory_usage">Memory Usage</option>
                <option value="memory_mb">Memory (MB)</option>
                <option value="cpu_percent">CPU Percent</option>
                <option value="window_count">Window Count</option>
                <option value="test_metric">Test Metric</option>
            </select>
        </div>

        <div class="form-group">
            <label for="aggregation">Aggregation</label>
            <select id="aggregation" name="aggregation">
                <option value="all">All Values</option>
                <option value="peak">Peak per Session</option>
                <option value="average">Average per Session</option>
                <option value="min">Min per Session</option>
            </select>
        </div>

        <div class="form-group">
            <label for="filter_mode">Filter Mode</label>
            <select id="filter_mode" name="filter_mode" onchange="toggleFilterInputs()">
                <option value="none">No Filter</option>
                <option value="current_state">Current State</option>
                <option value="state_history">State History (Ever Had)</option>
                <option value="state_array_contains">State Array Contains</option>
            </select>
        </div>

        <div class="form-group" id="filter_path_group" style="display: none;">
            <label for="filter_path">State Path</label>
            <input type="text" id="filter_path" name="filter_path" placeholder="e.g., application.status or window_state.open">
            <small style="color: #666;">Use dot notation for nested paths</small>
        </div>

        <div class="form-group" id="filter_value_group" style="display: none;">
            <label for="filter_value">Filter Value</label>
            <input type="text" id="filter_value" name="filter_value" placeholder="e.g., running or space probe">
        </div>

        <div class="form-group">
            <label>&nbsp;</label>
            <button type="submit" class="btn">Generate Chart</button>
        </div>
    </form>

    <div id="stats-container" style="display: none;" class="stats-grid">
        <div class="stat-card">
            <h3>Sessions Matched</h3>
            <div class="value" id="stat-sessions">0</div>
        </div>
        <div class="stat-card">
            <h3>Peak Value</h3>
            <div class="value" id="stat-peak">0</div>
        </div>
        <div class="stat-card">
            <h3>Average Value</h3>
            <div class="value" id="stat-average">0</div>
        </div>
        <div class="stat-card">
            <h3>Min Value</h3>
            <div class="value" id="stat-min">0</div>
        </div>
    </div>

    <div class="chart-container">
        <canvas id="metricsChart"></canvas>
    </div>
</div>

<div class="card">
    <h2>Example Queries</h2>
    <div style="display: grid; gap: 15px;">
        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
            <h4 style="margin-bottom: 10px; color: #667eea;">ðŸ“Š Peak Memory for Sessions with "space probe" Window</h4>
            <p style="margin-bottom: 10px; color: #666;">Shows peak memory usage for sessions that ever had "space probe" in their open windows list.</p>
            <button class="btn btn-secondary" onclick="loadExample1()">Load Example</button>
        </div>
        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
            <h4 style="margin-bottom: 10px; color: #667eea;">ðŸ“ˆ CPU Usage for Running Applications</h4>
            <p style="margin-bottom: 10px; color: #666;">Shows all CPU usage metrics from sessions currently marked as running.</p>
            <button class="btn btn-secondary" onclick="loadExample2()">Load Example</button>
        </div>
        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
            <h4 style="margin-bottom: 10px; color: #667eea;">ðŸ’¾ Average Memory by Application Version</h4>
            <p style="margin-bottom: 10px; color: #666;">Compare average memory usage across different application versions.</p>
            <button class="btn btn-secondary" onclick="loadExample3()">Load Example</button>
        </div>
    </div>
</div>

<script>
let chart = null;
let globalTimeRangeStart = null;
let globalTimeRangeEnd = null;
let allDataPoints = null; // Store all fetched data

// Format date for datetime-local input
function formatDateTimeLocal(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
}

// Initialize time range based on current data
function initializeTimeRangeFromData(data) {
    if (!data || !data.points || data.points.length === 0) return;
    
    const timestamps = data.points.map(p => new Date(p.timestamp));
    const minTime = new Date(Math.min(...timestamps));
    const maxTime = new Date(Math.max(...timestamps));
    
    globalTimeRangeStart = minTime;
    globalTimeRangeEnd = maxTime;
    
    document.getElementById('time-range-start').value = formatDateTimeLocal(minTime);
    document.getElementById('time-range-end').value = formatDateTimeLocal(maxTime);
    updateTimeRangeInfo();
}

// Update time range info text
function updateTimeRangeInfo() {
    const info = document.getElementById('time-range-info');
    if (globalTimeRangeStart && globalTimeRangeEnd) {
        const durationMs = globalTimeRangeEnd - globalTimeRangeStart;
        const durationSec = (durationMs / 1000).toFixed(1);
        info.textContent = `Showing ${durationSec}s range`;
    }
}

// Apply time range filter
function applyTimeRange() {
    const startInput = document.getElementById('time-range-start').value;
    const endInput = document.getElementById('time-range-end').value;
    
    if (!startInput || !endInput) {
        alert('Please select both start and end times');
        return;
    }
    
    globalTimeRangeStart = new Date(startInput);
    globalTimeRangeEnd = new Date(endInput);
    
    if (globalTimeRangeStart >= globalTimeRangeEnd) {
        alert('Start time must be before end time');
        return;
    }
    
    updateTimeRangeInfo();
    
    // Re-render chart with filtered data
    if (allDataPoints) {
        renderChartWithTimeRange(allDataPoints);
    }
}

// Reset time range
function resetTimeRange() {
    if (allDataPoints) {
        initializeTimeRangeFromData(allDataPoints);
        renderChartWithTimeRange(allDataPoints);
    }
}

// Render chart with time range filtering
function renderChartWithTimeRange(data) {
    const filteredData = {
        ...data,
        points: data.points.filter(p => {
            const timestamp = new Date(p.timestamp);
            return (!globalTimeRangeStart || timestamp >= globalTimeRangeStart) &&
                   (!globalTimeRangeEnd || timestamp <= globalTimeRangeEnd);
        })
    };
    
    // Recalculate stats for filtered data
    if (filteredData.points.length > 0) {
        const values = filteredData.points.map(p => p.value);
        filteredData.peak = Math.max(...values);
        filteredData.min = Math.min(...values);
        filteredData.average = values.reduce((a, b) => a + b, 0) / values.length;
    }
    
    renderChart(filteredData);
    updateStats(filteredData);
}

function toggleFilterInputs() {
    const filterMode = document.getElementById('filter_mode').value;
    const pathGroup = document.getElementById('filter_path_group');
    const valueGroup = document.getElementById('filter_value_group');
    
    if (filterMode === 'none') {
        pathGroup.style.display = 'none';
        valueGroup.style.display = 'none';
    } else {
        pathGroup.style.display = 'flex';
        valueGroup.style.display = 'flex';
    }
}

function loadExample1() {
    document.getElementById('metric_name').value = 'memory_usage';
    document.getElementById('aggregation').value = 'peak';
    document.getElementById('filter_mode').value = 'state_array_contains';
    toggleFilterInputs();
    document.getElementById('filter_path').value = 'window_state.open';
    document.getElementById('filter_value').value = 'space probe';
    document.getElementById('metrics-form').dispatchEvent(new Event('submit'));
}

function loadExample2() {
    document.getElementById('metric_name').value = 'cpu_usage';
    document.getElementById('aggregation').value = 'all';
    document.getElementById('filter_mode').value = 'current_state';
    toggleFilterInputs();
    document.getElementById('filter_path').value = 'application.status';
    document.getElementById('filter_value').value = 'running';
    document.getElementById('metrics-form').dispatchEvent(new Event('submit'));
}

function loadExample3() {
    document.getElementById('metric_name').value = 'memory_usage';
    document.getElementById('aggregation').value = 'average';
    document.getElementById('filter_mode').value = 'none';
    toggleFilterInputs();
    document.getElementById('metrics-form').dispatchEvent(new Event('submit'));
}

document.getElementById('metrics-form').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const metricName = document.getElementById('metric_name').value;
    const aggregation = document.getElementById('aggregation').value;
    const filterMode = document.getElementById('filter_mode').value;
    const filterPath = document.getElementById('filter_path').value;
    const filterValue = document.getElementById('filter_value').value;
    
    if (!metricName) {
        alert('Please select a metric name');
        return;
    }
    
    // Build query params
    const params = new URLSearchParams({
        metric: metricName,
        aggregation: aggregation,
        filter_mode: filterMode
    });
    
    if (filterMode !== 'none' && filterPath) {
        params.append('filter_path', filterPath);
        params.append('filter_value', filterValue);
    }
    
    try {
        const response = await fetch(`/api/timeseries?${params}`);
        const data = await response.json();
        
        // Store the data globally
        allDataPoints = data;
        
        // Initialize time range from data
        initializeTimeRangeFromData(data);
        
        renderChart(data);
        updateStats(data);
    } catch (error) {
        console.error('Error fetching data:', error);
        alert('Error loading metrics data');
    }
});

function updateStats(data) {
    const container = document.getElementById('stats-container');
    container.style.display = 'grid';
    
    document.getElementById('stat-sessions').textContent = data.sessions_matched || 0;
    document.getElementById('stat-peak').textContent = data.peak ? data.peak.toFixed(2) : '0';
    document.getElementById('stat-average').textContent = data.average ? data.average.toFixed(2) : '0';
    document.getElementById('stat-min').textContent = data.min ? data.min.toFixed(2) : '0';
}

function renderChart(data) {
    const ctx = document.getElementById('metricsChart').getContext('2d');
    
    if (chart) {
        chart.destroy();
    }
    
    // Calculate time range from all data points
    let minTime = null;
    let maxTime = null;
    
    if (data.points.length > 0) {
        minTime = new Date(Math.min(...data.points.map(p => new Date(p.timestamp).getTime())));
        maxTime = new Date(Math.max(...data.points.map(p => new Date(p.timestamp).getTime())));
    }
    
    // Calculate point radius based on data density
    const pointRadius = data.points.length > 100 ? 2 : (data.points.length > 50 ? 3 : 4);
    
    chart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: data.metric_name,
                data: data.points.map(p => ({
                    x: new Date(p.timestamp).getTime(),
                    y: p.value,
                    sessionId: p.session_id
                })),
                borderColor: 'rgb(102, 126, 234)',
                backgroundColor: 'rgba(102, 126, 234, 0.1)',
                tension: 0.1,
                fill: true,
                pointRadius: pointRadius,
                pointHoverRadius: pointRadius + 2,
                pointBackgroundColor: 'rgb(102, 126, 234)',
                pointBorderColor: '#ffffff',
                pointBorderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            },
            plugins: {
                title: {
                    display: true,
                    text: `${data.metric_name} - ${data.aggregation_type || 'All Values'}`,
                    font: {
                        size: 16
                    }
                },
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const timestamp = new Date(context[0].parsed.x);
                            return timestamp.toLocaleString();
                        },
                        label: function(context) {
                            return `Value: ${context.parsed.y.toFixed(2)}`;
                        },
                        afterLabel: function(context) {
                            const point = context.raw;
                            return `Session: ${point.sessionId.substring(0, 8)}...`;
                        }
                    }
                },
                zoom: typeof Chart.Zoom !== 'undefined' ? {
                    zoom: {
                        drag: {
                            enabled: true,
                            backgroundColor: 'rgba(102, 126, 234, 0.2)'
                        },
                        mode: 'x',
                        onZoomComplete: function({chart}) {
                            const xScale = chart.scales.x;
                            const newStart = new Date(xScale.min);
                            const newEnd = new Date(xScale.max);
                            
                            globalTimeRangeStart = newStart;
                            globalTimeRangeEnd = newEnd;
                            
                            document.getElementById('time-range-start').value = formatDateTimeLocal(newStart);
                            document.getElementById('time-range-end').value = formatDateTimeLocal(newEnd);
                            updateTimeRangeInfo();
                            
                            renderChartWithTimeRange(allDataPoints);
                        }
                    }
                } : undefined
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Value'
                    },
                    grid: {
                        color: 'rgba(160, 174, 192, 0.1)'
                    },
                    ticks: {
                        color: '#a0aec0'
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        displayFormats: {
                            millisecond: 'HH:mm:ss.SSS',
                            second: 'HH:mm:ss',
                            minute: 'HH:mm',
                            hour: 'HH:mm',
                            day: 'MMM dd'
                        },
                        tooltipFormat: 'yyyy-MM-dd HH:mm:ss'
                    },
                    min: minTime ? minTime.getTime() : undefined,
                    max: maxTime ? maxTime.getTime() : undefined,
                    title: {
                        display: true,
                        text: 'Time (drag to zoom)'
                    },
                    grid: {
                        color: 'rgba(160, 174, 192, 0.1)'
                    },
                    ticks: {
                        color: '#a0aec0',
                        maxRotation: 45,
                        minRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: 10
                    }
                }
            }
        }
    });
}
</script>
{{end}}
